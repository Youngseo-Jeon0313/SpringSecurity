# CSRF (Cross Site Request Forgery)

## CSRF란?
악의적인 웹사이트나 이메일을 통해 사용자가 의도하지 않은 요청을 보내도록 유도하여 공격하는 기법   
상황?   
![img.png](images/img.png)
1. 희생자가 위조 요청을 보낼 사이트에 로그인 되어있는 상태로 피싱 사이트에 접속합니다.
공격자는 피싱 사이트 접속 유도를 위해 피싱 메일, 팝업 광고를 띄우는 등의 행동을 합니다.

2. 희생자가 피싱 사이트에 접속하면 피싱 사이트에서 희생자로 가장하여 요청을 위조해 전송합니다.

3. 위조 요청을 받은 사이트는 해당 요청에 대한 응답을 하게 되고 이로 인해 희생자가 의도하지 않은 행동이 실행됩니다.

## CSRF 예방
1. 동기화 토큰 패턴 사용
   사용자의 세션에 임의의 값을 저장해 모든 요청마다 그 값을 포함하여 전송한다.   
   그리고 요청이 들어올 때마다 백엔드에서는 세션에 저장된 값과 요청으로 전송된 값이 일치하는지 검증하여 방어한다.

2. 세션 쿠키에서 SameSite 특성 지정
   쿠키가 SameSite 제약을 가진 동일한 사이트에서만 요청에 포함되도록 제한하는 옵션 등을 지정 할 수 있다.

3. GET, HEAD, OPTIONS, TRACE 메소드는 Read-Only로 어플리케이션의 상태를 변화시키지 않는다.

## CSRF 고려사항들
- 로그인할 때
- 로그아웃할 때
- CSRF와 세션 타임아웃 : 세션 타임아웃 후에도 CSRF 토큰이 유효하다면 보안에 취약해질 수 있다.
- file upload와 같은 Multipart를 사용할 때 CSRF Token을 Body나 URL 중에 포함시킨다.

# HTTP Headers
일단 기본 HTTP header는 이거임
```http request
Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0
X-Content-Type-Options: nosniff
Strict-Transport-Security: max-age=31536000 ; includeSubDomains
X-Frame-Options: DENY
X-XSS-Protection: 0
```
아래 여러 추가적인 요소들을 추가할 수 있다.    
- Cache Control
- Content Type Options
- HTTP Strict Transport Security
- X-Frame-Options
- X-XSS-Protection
필요할 때 잘 찾아서 쓰면 될 것 !

# HTTP Requests
HTTPS로 리디렉션
Strict Transport Security
프록시 서버 구성 -> 로드밸런서로 연결되고 있음을 알리기 위해 X-Forwarded-For 헤더를 사용해 클라이언트의 실제 IP   
주소를 서버에 전달할 수 있다. springboot에서는 server.forward-headers-strategy 속성을 사용해 구성 가능 !